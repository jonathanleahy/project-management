package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"database/sql"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/project-management/backend/auth"
	"github.com/project-management/backend/graph/model"
)

// Register creates a new user account
func (r *mutationResolver) Register(ctx context.Context, email string, password string, name string) (*model.AuthPayload, error) {
	// Validate password
	if err := auth.ValidatePassword(password); err != nil {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, err
	}

	// Hash password
	hashedPassword, err := auth.HashPassword(password)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, err
	}

	// Generate ID
	id, err := GenerateID(r.DB)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, err
	}

	// Insert user
	_, err = r.DB.Exec(`
		INSERT INTO users (id, email, name, password_hash, created_at)
		VALUES (?, ?, ?, ?, NOW())
	`, id, email, name, hashedPassword)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, fmt.Errorf("email already exists")
	}

	user := &model.User{
		ID:        id,
		Email:     email,
		Name:      name,
		CreatedAt: time.Now(),
	}

	return &model.AuthPayload{
		Success: true,
		User:    user,
	}, nil
}

// Login authenticates a user
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user model.User
	var passwordHash string
	err := r.DB.QueryRow("SELECT id, email, name, password_hash, created_at FROM users WHERE email = ?", email).Scan(
		&user.ID, &user.Email, &user.Name, &passwordHash, &user.CreatedAt,
	)
	if err != nil {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, fmt.Errorf("invalid credentials")
	}

	// Check password
	if !auth.CheckPassword(password, passwordHash) {
		return &model.AuthPayload{
			Success: false,
			User:    nil,
		}, fmt.Errorf("invalid credentials")
	}

	// Create session - need response writer and request from context
	if ginCtx, ok := ctx.Value("GinContext").(map[string]interface{}); ok {
		if w, ok := ginCtx["ResponseWriter"].(http.ResponseWriter); ok {
			if req, ok := ginCtx["Request"].(*http.Request); ok {
				err = r.SessionStore.CreateSession(w, req, user.ID, r.DB)
				if err != nil {
					return &model.AuthPayload{
						Success: false,
						User:    nil,
					}, err
				}
			}
		}
	}

	return &model.AuthPayload{
		Success: true,
		User:    &user,
	}, nil
}

// Logout ends the user session
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	_, ok := auth.GetUserID(ctx)
	if !ok {
		return false, nil
	}

	// Destroy session using response writer and request from context
	if ginCtx, ok := ctx.Value("GinContext").(map[string]interface{}); ok {
		if w, ok := ginCtx["ResponseWriter"].(http.ResponseWriter); ok {
			if req, ok := ginCtx["Request"].(*http.Request); ok {
				err := r.SessionStore.DestroySession(w, req, r.DB)
				if err != nil {
					// Log error but still return success
					fmt.Printf("Error destroying session: %v\n", err)
				}
			}
		}
	}

	return true, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, email string) (bool, error) {
	panic(fmt.Errorf("not implemented: ResetPassword - resetPassword"))
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	panic(fmt.Errorf("not implemented: ChangePassword - changePassword"))
}

// CreateProject creates a new project
func (r *mutationResolver) CreateProject(ctx context.Context, name string, description *string) (*model.Project, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	id, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	desc := ""
	if description != nil {
		desc = *description
	}

	// Start transaction
	tx, err := r.DB.Beginx()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Insert project
	_, err = tx.Exec(`
		INSERT INTO projects (id, name, description, owner_id, created_at, updated_at)
		VALUES (?, ?, ?, ?, NOW(), NOW())
	`, id, name, desc, userID)
	if err != nil {
		return nil, err
	}

	// Add owner to project_roles
	roleID, _ := GenerateID(r.DB)
	_, err = tx.Exec(`
		INSERT INTO project_roles (id, project_id, user_id, role, created_at)
		VALUES (?, ?, ?, 'OWNER', NOW())
	`, roleID, id, userID)
	if err != nil {
		return nil, err
	}

	// Create default workflow
	workflows := []struct {
		name     string
		color    string
		position int
		terminal bool
	}{
		{"To Do", "#94a3b8", 0, false},
		{"In Progress", "#3b82f6", 1, false},
		{"Done", "#10b981", 2, true},
	}

	for _, w := range workflows {
		wfID, _ := GenerateID(r.DB)
		_, err = tx.Exec(`
			INSERT INTO project_workflow (id, project_id, name, color, position, is_terminal)
			VALUES (?, ?, ?, ?, ?, ?)
		`, wfID, id, w.name, w.color, w.position, w.terminal)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return &model.Project{
		ID:          id,
		Name:        name,
		Description: &desc,
		OwnerID:     userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}, nil
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, id string, name *string, description *string) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: UpdateProject - updateProject"))
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteProject - deleteProject"))
}

// AddMember is the resolver for the addMember field.
func (r *mutationResolver) AddMember(ctx context.Context, projectID string, userID string, role model.Role) (*model.ProjectRole, error) {
	panic(fmt.Errorf("not implemented: AddMember - addMember"))
}

// UpdateMemberRole is the resolver for the updateMemberRole field.
func (r *mutationResolver) UpdateMemberRole(ctx context.Context, projectID string, userID string, role model.Role) (*model.ProjectRole, error) {
	panic(fmt.Errorf("not implemented: UpdateMemberRole - updateMemberRole"))
}

// RemoveMember is the resolver for the removeMember field.
func (r *mutationResolver) RemoveMember(ctx context.Context, projectID string, userID string) (bool, error) {
	panic(fmt.Errorf("not implemented: RemoveMember - removeMember"))
}

// SetProjectWorkflow is the resolver for the setProjectWorkflow field.
func (r *mutationResolver) SetProjectWorkflow(ctx context.Context, projectID string, statuses []*model.WorkflowStatusInput) ([]*model.WorkflowStatus, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check project access - only owners and admins can modify workflow
	var role string
	err := r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil || (role != "OWNER" && role != "ADMIN") {
		return nil, fmt.Errorf("only owners and admins can modify workflow")
	}

	tx, err := r.DB.Beginx()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Delete existing workflow
	_, err = tx.Exec("DELETE FROM project_workflow WHERE project_id = ?", projectID)
	if err != nil {
		return nil, err
	}

	// Insert new workflow
	var result []*model.WorkflowStatus
	for i, status := range statuses {
		id, err := GenerateID(r.DB)
		if err != nil {
			return nil, err
		}

		_, err = tx.Exec(`
			INSERT INTO project_workflow (
				id, project_id, name, color, position, is_terminal
			) VALUES (?, ?, ?, ?, ?, ?)
		`, id, projectID, status.Name, status.Color, i, status.IsTerminal)
		if err != nil {
			return nil, err
		}

		result = append(result, &model.WorkflowStatus{
			ID:         id,
			ProjectID:  projectID,
			Name:       status.Name,
			Color:      status.Color,
			Position:   i,
			IsTerminal: status.IsTerminal,
		})
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return result, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, input model.CreateTaskInput) (*model.Task, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check project access
	var role string
	err := r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, input.ProjectID, userID)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}

	// Only owners, admins, and members can create tasks
	if role == "VIEWER" {
		return nil, fmt.Errorf("viewers cannot create tasks")
	}

	id, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	// Calculate depth
	depth := 0
	if input.ParentID != nil {
		err = r.DB.Get(&depth, "SELECT depth FROM tasks WHERE id = ?", *input.ParentID)
		if err != nil {
			return nil, fmt.Errorf("parent task not found")
		}
		depth++
		if depth >= 4 {
			return nil, fmt.Errorf("maximum task depth (4 levels) reached")
		}
	}

	// Get next position
	var position int
	if input.ParentID != nil {
		err = r.DB.Get(&position, `
			SELECT COALESCE(MAX(position), -1) + 1 
			FROM tasks 
			WHERE project_id = ? AND parent_id = ?
		`, input.ProjectID, *input.ParentID)
	} else {
		err = r.DB.Get(&position, `
			SELECT COALESCE(MAX(position), -1) + 1 
			FROM tasks 
			WHERE project_id = ? AND parent_id IS NULL
		`, input.ProjectID)
	}
	if err != nil {
		position = 0
	}

	progressPct := 0
	if input.ProgressPct != nil {
		progressPct = *input.ProgressPct
	}

	// Insert task
	_, err = r.DB.Exec(`
		INSERT INTO tasks (
			id, project_id, parent_id, title, summary, status_id, 
			assignee_id, priority, due_date, progress_pct, position, 
			depth, created_at, updated_at
		) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
	`, id, input.ProjectID, input.ParentID, input.Title, input.Summary,
		input.StatusID, input.AssigneeID, input.Priority, input.DueDate,
		progressPct, position, depth)
	if err != nil {
		return nil, err
	}

	return &model.Task{
		ID:          id,
		ProjectID:   input.ProjectID,
		ParentID:    input.ParentID,
		Title:       input.Title,
		Summary:     input.Summary,
		StatusID:    input.StatusID,
		AssigneeID:  input.AssigneeID,
		Priority:    input.Priority,
		DueDate:     input.DueDate,
		ProgressPct: progressPct,
		Position:    position,
		Depth:       depth,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}, nil
}

// UpdateTask is the resolver for the updateTask field.
func (r *mutationResolver) UpdateTask(ctx context.Context, id string, input model.UpdateTaskInput) (*model.Task, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Get task and check access
	var task model.Task
	err := r.DB.Get(&task, "SELECT * FROM tasks WHERE id = ?", id)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	// Check project access
	var role string
	err = r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, task.ProjectID, userID)
	if err != nil || role == "VIEWER" {
		return nil, fmt.Errorf("access denied")
	}

	// Build update query
	updates := []string{"updated_at = NOW()"}
	args := []interface{}{}

	if input.Title != nil {
		updates = append(updates, "title = ?")
		args = append(args, *input.Title)
		task.Title = *input.Title
	}
	if input.Summary != nil {
		updates = append(updates, "summary = ?")
		args = append(args, *input.Summary)
		task.Summary = input.Summary
	}
	if input.StatusID != nil {
		updates = append(updates, "status_id = ?")
		args = append(args, *input.StatusID)
		task.StatusID = input.StatusID
	}
	if input.AssigneeID != nil {
		updates = append(updates, "assignee_id = ?")
		args = append(args, *input.AssigneeID)
		task.AssigneeID = input.AssigneeID
	}
	if input.Priority != nil {
		updates = append(updates, "priority = ?")
		args = append(args, *input.Priority)
		task.Priority = *input.Priority
	}
	if input.DueDate != nil {
		updates = append(updates, "due_date = ?")
		args = append(args, *input.DueDate)
		task.DueDate = input.DueDate
	}
	if input.ProgressPct != nil {
		updates = append(updates, "progress_pct = ?")
		args = append(args, *input.ProgressPct)
		task.ProgressPct = *input.ProgressPct
	}

	if len(updates) > 1 {
		args = append(args, id)
		query := fmt.Sprintf(
			"UPDATE tasks SET %s WHERE id = ?",
			strings.Join(updates, ", "),
		)
		_, err = r.DB.Exec(query, args...)
		if err != nil {
			return nil, err
		}
	}

	task.UpdatedAt = time.Now()
	return &task, nil
}

// DeleteTask is the resolver for the deleteTask field.
func (r *mutationResolver) DeleteTask(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTask - deleteTask"))
}

// ReorderTask is the resolver for the reorderTask field.
func (r *mutationResolver) ReorderTask(ctx context.Context, id string, position int) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: ReorderTask - reorderTask"))
}

// SetTaskStatus is the resolver for the setTaskStatus field.
func (r *mutationResolver) SetTaskStatus(ctx context.Context, id string, statusID string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: SetTaskStatus - setTaskStatus"))
}

// SetTaskAssignee is the resolver for the setTaskAssignee field.
func (r *mutationResolver) SetTaskAssignee(ctx context.Context, id string, assigneeID *string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: SetTaskAssignee - setTaskAssignee"))
}

// SetTaskProgress is the resolver for the setTaskProgress field.
func (r *mutationResolver) SetTaskProgress(ctx context.Context, id string, progressPct int) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: SetTaskProgress - setTaskProgress"))
}

// SetTaskDueDate is the resolver for the setTaskDueDate field.
func (r *mutationResolver) SetTaskDueDate(ctx context.Context, id string, dueDate *time.Time) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: SetTaskDueDate - setTaskDueDate"))
}

// SetDependencies is the resolver for the setDependencies field.
func (r *mutationResolver) SetDependencies(ctx context.Context, taskID string, blocks []string) (*model.Task, error) {
	panic(fmt.Errorf("not implemented: SetDependencies - setDependencies"))
}

// CreateDocument is the resolver for the createDocument field.
func (r *mutationResolver) CreateDocument(ctx context.Context, taskID string, name string, markdown string) (*model.Document, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check task access
	var projectID string
	err := r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	// Check project access
	var role string
	err = r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil || role == "VIEWER" {
		return nil, fmt.Errorf("access denied")
	}

	tx, err := r.DB.Beginx()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Create document
	docID, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	_, err = tx.Exec(`
		INSERT INTO documents (id, task_id, name, created_at)
		VALUES (?, ?, ?, NOW())
	`, docID, taskID, name)
	if err != nil {
		return nil, err
	}

	// Create first version
	versionID, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	_, err = tx.Exec(`
		INSERT INTO document_versions (
			id, document_id, version, markdown, author_id, created_at, is_active
		) VALUES (?, ?, 1, ?, ?, NOW(), TRUE)
	`, versionID, docID, markdown, userID)
	if err != nil {
		return nil, err
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return &model.Document{
		ID:        docID,
		TaskID:    taskID,
		Name:      name,
		CreatedAt: time.Now(),
		CurrentVersion: &model.DocVersion{
			ID:         versionID,
			DocumentID: docID,
			Version:    1,
			Markdown:   markdown,
			AuthorID:   userID,
			CreatedAt:  time.Now(),
			IsActive:   true,
		},
	}, nil
}

// UpdateDocument is the resolver for the updateDocument field.
func (r *mutationResolver) UpdateDocument(ctx context.Context, id string, name string) (*model.Document, error) {
	panic(fmt.Errorf("not implemented: UpdateDocument - updateDocument"))
}

// AddDocVersion is the resolver for the addDocVersion field.
func (r *mutationResolver) AddDocVersion(ctx context.Context, documentID string, markdown string) (*model.DocVersion, error) {
	panic(fmt.Errorf("not implemented: AddDocVersion - addDocVersion"))
}

// RestoreDocVersion is the resolver for the restoreDocVersion field.
func (r *mutationResolver) RestoreDocVersion(ctx context.Context, versionID string) (*model.DocVersion, error) {
	panic(fmt.Errorf("not implemented: RestoreDocVersion - restoreDocVersion"))
}

// DeleteDocument is the resolver for the deleteDocument field.
func (r *mutationResolver) DeleteDocument(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteDocument - deleteDocument"))
}

// CreateCanvas is the resolver for the createCanvas field.
func (r *mutationResolver) CreateCanvas(ctx context.Context, taskID string, name string, dataJSON string) (*model.Canvas, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check task access
	var projectID string
	err := r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	// Check project access
	var role string
	err = r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil || role == "VIEWER" {
		return nil, fmt.Errorf("access denied")
	}

	id, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.Exec(`
		INSERT INTO canvases (id, task_id, name, data_json, created_at, updated_at)
		VALUES (?, ?, ?, ?, NOW(), NOW())
	`, id, taskID, name, dataJSON)
	if err != nil {
		return nil, err
	}

	return &model.Canvas{
		ID:        id,
		TaskID:    taskID,
		Name:      name,
		DataJson:  dataJSON,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

// UpdateCanvas is the resolver for the updateCanvas field.
func (r *mutationResolver) UpdateCanvas(ctx context.Context, id string, name *string, dataJSON *string, thumbnail *string) (*model.Canvas, error) {
	_, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Verify ownership/access to canvas
	var taskID string
	err := r.DB.Get(&taskID, "SELECT task_id FROM canvases WHERE id = ?", id)
	if err != nil {
		return nil, fmt.Errorf("canvas not found")
	}

	// Check task access via project membership
	var projectID string
	err = r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	if !auth.HasProjectPermission(ctx, r.DB, projectID, "MEMBER") {
		return nil, fmt.Errorf("unauthorized to edit canvas")
	}

	// Build update query dynamically
	updates := []string{}
	args := []interface{}{}

	if name != nil {
		updates = append(updates, "name = ?")
		args = append(args, *name)
	}

	if dataJSON != nil {
		updates = append(updates, "data_json = ?")
		args = append(args, *dataJSON)
	}

	if thumbnail != nil {
		updates = append(updates, "thumbnail = ?")
		args = append(args, *thumbnail)
	}

	if len(updates) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	updates = append(updates, "updated_at = NOW()")
	args = append(args, id)

	query := fmt.Sprintf("UPDATE canvases SET %s WHERE id = ?", strings.Join(updates, ", "))
	_, err = r.DB.Exec(query, args...)
	if err != nil {
		return nil, err
	}

	// Fetch and return updated canvas
	var canvas model.Canvas
	err = r.DB.Get(&canvas, `
		SELECT id, task_id, name, thumbnail, CAST(data_json AS CHAR) as data_json, created_at, updated_at 
		FROM canvases WHERE id = ?
	`, id)
	if err != nil {
		return nil, err
	}

	return &canvas, nil
}

// DeleteCanvas is the resolver for the deleteCanvas field.
func (r *mutationResolver) DeleteCanvas(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return false, fmt.Errorf("access denied")
	}

	// Check if canvas exists and user has access
	var canvas struct {
		TaskID    string `db:"task_id"`
		ProjectID string `db:"project_id"`
	}
	err := r.DB.Get(&canvas, `
		SELECT c.task_id, t.project_id 
		FROM canvases c
		JOIN tasks t ON c.task_id = t.id
		WHERE c.id = ?
	`, id)
	if err != nil {
		return false, err
	}

	// Check project access
	if !hasProjectAccess(r.DB, userID, canvas.ProjectID, "MEMBER") {
		return false, fmt.Errorf("access denied")
	}

	// Delete canvas
	_, err = r.DB.Exec("DELETE FROM canvases WHERE id = ?", id)
	return err == nil, err
}

// CreateAttachment is the resolver for the createAttachment field.
func (r *mutationResolver) CreateAttachment(ctx context.Context, taskID string, typeArg model.AttachmentType, name string, url string, size int, mimeType string) (*model.Attachment, error) {
	panic(fmt.Errorf("not implemented: CreateAttachment - createAttachment"))
}

// DeleteAttachment is the resolver for the deleteAttachment field.
func (r *mutationResolver) DeleteAttachment(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAttachment - deleteAttachment"))
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, taskID string, content string) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("access denied")
	}

	// Check if task exists and user has access
	var projectID string
	err := r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	if !hasProjectAccess(r.DB, userID, projectID, "VIEWER") {
		return nil, fmt.Errorf("access denied")
	}

	// Create comment
	id := uuid.New().String()
	now := time.Now()

	_, err = r.DB.Exec(`
		INSERT INTO comments (id, task_id, user_id, content, created_at, updated_at)
		VALUES (?, ?, ?, ?, ?, ?)
	`, id, taskID, userID, content, now, now)
	if err != nil {
		return nil, err
	}

	// Also log to activity
	activityID := uuid.New().String()
	_, err = r.DB.Exec(`
		INSERT INTO activity_log (id, task_id, project_id, user_id, action, new_value, created_at)
		VALUES (?, ?, ?, ?, 'commented', ?, ?)
	`, activityID, taskID, projectID, userID, content, now)

	// Get user info
	var user model.User
	err = r.DB.Get(&user, "SELECT id, email, name, created_at FROM users WHERE id = ?", userID)
	if err != nil {
		return nil, err
	}

	return &model.Comment{
		ID:        id,
		TaskID:    taskID,
		User:      &user,
		Content:   content,
		CreatedAt: now,
		UpdatedAt: now,
	}, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, id string, content string) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("access denied")
	}

	// Check if comment exists and user owns it
	var comment model.Comment
	var dbUserID string
	err := r.DB.QueryRow(`
		SELECT id, task_id, user_id, content, created_at, updated_at
		FROM comments WHERE id = ?
	`, id).Scan(&comment.ID, &comment.TaskID, &dbUserID, &comment.Content, &comment.CreatedAt, &comment.UpdatedAt)
	if err != nil {
		return nil, fmt.Errorf("comment not found")
	}

	if dbUserID != userID {
		return nil, fmt.Errorf("access denied")
	}

	// Update comment
	now := time.Now()
	_, err = r.DB.Exec(`
		UPDATE comments SET content = ?, updated_at = ? WHERE id = ?
	`, content, now, id)
	if err != nil {
		return nil, err
	}

	// Get user info
	var user model.User
	err = r.DB.Get(&user, "SELECT id, email, name, created_at FROM users WHERE id = ?", userID)
	if err != nil {
		return nil, err
	}

	comment.User = &user
	comment.Content = content
	comment.UpdatedAt = now

	return &comment, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string) (bool, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return false, fmt.Errorf("access denied")
	}

	// Check if comment exists and user owns it or is admin
	var dbUserID, taskID, projectID string
	err := r.DB.QueryRow(`
		SELECT c.user_id, c.task_id, t.project_id
		FROM comments c
		JOIN tasks t ON c.task_id = t.id
		WHERE c.id = ?
	`, id).Scan(&dbUserID, &taskID, &projectID)
	if err != nil {
		return false, fmt.Errorf("comment not found")
	}

	// Check if user owns the comment or is project admin
	if dbUserID != userID && !hasProjectAccess(r.DB, userID, projectID, "ADMIN") {
		return false, fmt.Errorf("access denied")
	}

	// Delete comment
	_, err = r.DB.Exec("DELETE FROM comments WHERE id = ?", id)
	return err == nil, err
}

// CreateShareCode is the resolver for the createShareCode field.
func (r *mutationResolver) CreateShareCode(ctx context.Context, projectID string, role model.Role, expiresAt *time.Time, maxUses *int) (*model.ShareCode, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check project access - only owners and admins can create share codes
	var userRole string
	err := r.DB.Get(&userRole, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil || (userRole != "OWNER" && userRole != "ADMIN") {
		return nil, fmt.Errorf("only owners and admins can create share codes")
	}

	id, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	// Generate unique code
	code := generateShareCode()

	_, err = r.DB.Exec(`
		INSERT INTO share_codes (
			id, project_id, code, role, expires_at, max_uses, uses, revoked, created_at, created_by
		) VALUES (?, ?, ?, ?, ?, ?, 0, FALSE, NOW(), ?)
	`, id, projectID, code, role, expiresAt, maxUses, userID)
	if err != nil {
		return nil, err
	}

	return &model.ShareCode{
		ID:        id,
		ProjectID: projectID,
		Code:      code,
		Role:      role,
		ExpiresAt: expiresAt,
		MaxUses:   maxUses,
		Uses:      0,
		Revoked:   false,
		CreatedAt: time.Now(),
	}, nil
}

// RedeemShareCode is the resolver for the redeemShareCode field.
func (r *mutationResolver) RedeemShareCode(ctx context.Context, code string) (*model.ProjectRole, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	tx, err := r.DB.Beginx()
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	// Get share code
	var shareCode struct {
		ID        string     `db:"id"`
		ProjectID string     `db:"project_id"`
		Role      model.Role `db:"role"`
		ExpiresAt *time.Time `db:"expires_at"`
		MaxUses   *int       `db:"max_uses"`
		Uses      int        `db:"uses"`
		Revoked   bool       `db:"revoked"`
	}

	err = tx.Get(&shareCode, `
		SELECT id, project_id, role, expires_at, max_uses, uses, revoked
		FROM share_codes
		WHERE code = ?
	`, code)
	if err != nil {
		return nil, fmt.Errorf("invalid share code")
	}

	// Validate share code
	if shareCode.Revoked {
		return nil, fmt.Errorf("share code has been revoked")
	}
	if shareCode.ExpiresAt != nil && shareCode.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("share code has expired")
	}
	if shareCode.MaxUses != nil && shareCode.Uses >= *shareCode.MaxUses {
		return nil, fmt.Errorf("share code has reached maximum uses")
	}

	// Check if user is already a member
	var existingRole string
	err = tx.Get(&existingRole, `
		SELECT role FROM project_roles
		WHERE project_id = ? AND user_id = ?
	`, shareCode.ProjectID, userID)
	if err == nil {
		return nil, fmt.Errorf("you are already a member of this project")
	}

	// Add user to project
	roleID, err := GenerateID(r.DB)
	if err != nil {
		return nil, err
	}

	_, err = tx.Exec(`
		INSERT INTO project_roles (id, project_id, user_id, role, created_at)
		VALUES (?, ?, ?, ?, NOW())
	`, roleID, shareCode.ProjectID, userID, shareCode.Role)
	if err != nil {
		return nil, err
	}

	// Increment uses
	_, err = tx.Exec(`
		UPDATE share_codes SET uses = uses + 1
		WHERE id = ?
	`, shareCode.ID)
	if err != nil {
		return nil, err
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}

	return &model.ProjectRole{
		ID:        roleID,
		ProjectID: shareCode.ProjectID,
		UserID:    userID,
		Role:      shareCode.Role,
		CreatedAt: time.Now(),
	}, nil
}

// RevokeShareCode is the resolver for the revokeShareCode field.
func (r *mutationResolver) RevokeShareCode(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: RevokeShareCode - revokeShareCode"))
}

// Me returns the current authenticated user
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, nil
	}

	var user model.User
	err := r.DB.Get(&user, "SELECT id, email, name, created_at FROM users WHERE id = ?", userID)
	if err != nil {
		return nil, err
	}

	return &user, nil
}

// ListProjects returns all projects for the current user
func (r *queryResolver) ListProjects(ctx context.Context) ([]*model.Project, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	rows, err := r.DB.Query(`
		SELECT DISTINCT p.id, p.name, p.description, p.owner_id, p.created_at, p.updated_at
		FROM projects p
		LEFT JOIN project_roles pr ON p.id = pr.project_id
		WHERE p.owner_id = ? OR pr.user_id = ?
	`, userID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var projects []*model.Project
	for rows.Next() {
		var p model.Project
		err := rows.Scan(&p.ID, &p.Name, &p.Description, &p.OwnerID, &p.CreatedAt, &p.UpdatedAt)
		if err != nil {
			return nil, err
		}
		projects = append(projects, &p)
	}

	return projects, nil
}

// GetProject returns a specific project by ID
func (r *queryResolver) GetProject(ctx context.Context, id string) (*model.Project, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	var project model.Project
	err := r.DB.Get(&project, `
		SELECT p.* FROM projects p
		LEFT JOIN project_roles pr ON p.id = pr.project_id
		WHERE p.id = ? AND (p.owner_id = ? OR pr.user_id = ?)
		LIMIT 1
	`, id, userID, userID)
	if err != nil {
		return nil, err
	}

	return &project, nil
}

// ListTasks is the resolver for the listTasks field.
func (r *queryResolver) ListTasks(ctx context.Context, projectID string, parentID *string, filter *model.TaskFilter, pagination *model.Pagination) (*model.TaskPage, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check project access
	var role string
	err := r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}

	// Build query
	query := `
		SELECT t.*, 
			(SELECT COUNT(*) FROM documents WHERE task_id = t.id) as document_count,
			(SELECT COUNT(*) FROM canvases WHERE task_id = t.id) as canvas_count,
			(SELECT COUNT(*) FROM attachments WHERE task_id = t.id) as attachment_count
		FROM tasks t
		WHERE t.project_id = ?
	`
	args := []interface{}{projectID}

	if parentID != nil {
		query += " AND t.parent_id = ?"
		args = append(args, *parentID)
	} else {
		query += " AND t.parent_id IS NULL"
	}

	// Apply filters
	if filter != nil {
		if filter.Status != nil {
			query += " AND t.status_id = ?"
			args = append(args, *filter.Status)
		}
		if filter.AssigneeID != nil {
			query += " AND t.assignee_id = ?"
			args = append(args, *filter.AssigneeID)
		}
		if filter.Priority != nil {
			query += " AND t.priority = ?"
			args = append(args, *filter.Priority)
		}
		if filter.Search != nil {
			query += " AND (t.title LIKE ? OR t.summary LIKE ?)"
			searchTerm := "%" + *filter.Search + "%"
			args = append(args, searchTerm, searchTerm)
		}
	}

	query += " ORDER BY t.position"

	// Apply pagination
	limit := 50
	offset := 0
	if pagination != nil {
		if pagination.Limit > 0 {
			limit = pagination.Limit
		}
		if pagination.Page > 0 {
			offset = (pagination.Page - 1) * limit
		}
	}

	query += " LIMIT ? OFFSET ?"
	args = append(args, limit, offset)

	var tasks []*model.Task
	err = r.DB.Select(&tasks, query, args...)
	if err != nil {
		return nil, err
	}

	// Get total count
	var total int
	countQuery := "SELECT COUNT(*) FROM tasks WHERE project_id = ?"
	countArgs := []interface{}{projectID}
	if parentID != nil {
		countQuery += " AND parent_id = ?"
		countArgs = append(countArgs, *parentID)
	} else {
		countQuery += " AND parent_id IS NULL"
	}
	err = r.DB.Get(&total, countQuery, countArgs...)
	if err != nil {
		return nil, err
	}

	pages := (total + limit - 1) / limit
	currentPage := 1
	if pagination != nil && pagination.Page > 0 {
		currentPage = pagination.Page
	}

	return &model.TaskPage{
		Tasks: tasks,
		PageInfo: &model.PageInfo{
			Total:   total,
			Page:    currentPage,
			Pages:   pages,
			HasNext: currentPage < pages,
			HasPrev: currentPage > 1,
		},
	}, nil
}

// GetTask is the resolver for the getTask field.
func (r *queryResolver) GetTask(ctx context.Context, id string) (*model.Task, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	var task model.Task
	err := r.DB.Get(&task, `
		SELECT t.*, 
			(SELECT COUNT(*) FROM documents WHERE task_id = t.id) as document_count,
			(SELECT COUNT(*) FROM canvases WHERE task_id = t.id) as canvas_count,
			(SELECT COUNT(*) FROM attachments WHERE task_id = t.id) as attachment_count
		FROM tasks t
		WHERE t.id = ?
	`, id)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	// Check project access
	var role string
	err = r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, task.ProjectID, userID)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}

	return &task, nil
}

// GetTaskDocuments is the resolver for the getTaskDocuments field.
func (r *queryResolver) GetTaskDocuments(ctx context.Context, taskID string) ([]*model.Document, error) {
	_, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	var documents []*model.Document
	err := r.DB.Select(&documents, `
		SELECT id, task_id, name, markdown, created_at, updated_at
		FROM documents
		WHERE task_id = ?
		ORDER BY created_at DESC
	`, taskID)
	if err != nil {
		return nil, err
	}

	return documents, nil
}

// GetTaskCanvases is the resolver for the getTaskCanvases field.
func (r *queryResolver) GetTaskCanvases(ctx context.Context, taskID string) ([]*model.Canvas, error) {
	_, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	var canvases []*model.Canvas
	err := r.DB.Select(&canvases, `
		SELECT id, task_id, name, thumbnail, CAST(data_json AS CHAR) as data_json, created_at, updated_at
		FROM canvases
		WHERE task_id = ?
		ORDER BY created_at DESC
	`, taskID)
	if err != nil {
		return nil, err
	}

	return canvases, nil
}

// GetDocument is the resolver for the getDocument field.
func (r *queryResolver) GetDocument(ctx context.Context, id string) (*model.Document, error) {
	panic(fmt.Errorf("not implemented: GetDocument - getDocument"))
}

// GetDocVersions is the resolver for the getDocVersions field.
func (r *queryResolver) GetDocVersions(ctx context.Context, documentID string) ([]*model.DocVersion, error) {
	panic(fmt.Errorf("not implemented: GetDocVersions - getDocVersions"))
}

// GetCanvas is the resolver for the getCanvas field.
func (r *queryResolver) GetCanvas(ctx context.Context, id string) (*model.Canvas, error) {
	panic(fmt.Errorf("not implemented: GetCanvas - getCanvas"))
}

// GetTaskComments is the resolver for the getTaskComments field.
func (r *queryResolver) GetTaskComments(ctx context.Context, taskID string) ([]*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("access denied")
	}

	// Check if user has access to the task's project
	var projectID string
	err := r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	if !hasProjectAccess(r.DB, userID, projectID, "VIEWER") {
		return nil, fmt.Errorf("access denied")
	}

	// Get comments
	rows, err := r.DB.Query(`
		SELECT c.id, c.task_id, c.user_id, c.content, c.created_at, c.updated_at,
		       u.id, u.email, u.name, u.created_at
		FROM comments c
		JOIN users u ON c.user_id = u.id
		WHERE c.task_id = ?
		ORDER BY c.created_at DESC
	`, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []*model.Comment
	for rows.Next() {
		var comment model.Comment
		var user model.User
		err := rows.Scan(
			&comment.ID, &comment.TaskID, &user.ID, &comment.Content, &comment.CreatedAt, &comment.UpdatedAt,
			&user.ID, &user.Email, &user.Name, &user.CreatedAt,
		)
		if err != nil {
			return nil, err
		}
		comment.User = &user
		comments = append(comments, &comment)
	}

	return comments, nil
}

// GetTaskActivity is the resolver for the getTaskActivity field.
func (r *queryResolver) GetTaskActivity(ctx context.Context, taskID string, limit *int) ([]*model.Activity, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("access denied")
	}

	// Check if user has access to the task's project
	var projectID string
	err := r.DB.Get(&projectID, "SELECT project_id FROM tasks WHERE id = ?", taskID)
	if err != nil {
		return nil, fmt.Errorf("task not found")
	}

	if !hasProjectAccess(r.DB, userID, projectID, "VIEWER") {
		return nil, fmt.Errorf("access denied")
	}

	// Build query
	query := `
		SELECT a.id, a.task_id, a.project_id, a.user_id, a.action, 
		       a.old_value, a.new_value, a.metadata, a.created_at,
		       u.id, u.email, u.name, u.created_at
		FROM activity_log a
		JOIN users u ON a.user_id = u.id
		WHERE a.task_id = ?
		ORDER BY a.created_at DESC
	`

	if limit != nil && *limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}

	rows, err := r.DB.Query(query, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var activities []*model.Activity
	for rows.Next() {
		var activity model.Activity
		var user model.User
		var oldValue, newValue, metadata sql.NullString

		err := rows.Scan(
			&activity.ID, &activity.TaskID, &activity.ProjectID, &user.ID, &activity.Action,
			&oldValue, &newValue, &metadata, &activity.CreatedAt,
			&user.ID, &user.Email, &user.Name, &user.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		if oldValue.Valid {
			activity.OldValue = &oldValue.String
		}
		if newValue.Valid {
			activity.NewValue = &newValue.String
		}
		if metadata.Valid {
			activity.Metadata = &metadata.String
		}

		activity.User = &user
		activities = append(activities, &activity)
	}

	return activities, nil
}

// GetProjectActivity is the resolver for the getProjectActivity field.
func (r *queryResolver) GetProjectActivity(ctx context.Context, projectID string, limit *int) ([]*model.Activity, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("access denied")
	}

	if !hasProjectAccess(r.DB, userID, projectID, "VIEWER") {
		return nil, fmt.Errorf("access denied")
	}

	// Build query
	query := `
		SELECT a.id, a.task_id, a.project_id, a.user_id, a.action, 
		       a.old_value, a.new_value, a.metadata, a.created_at,
		       u.id, u.email, u.name, u.created_at
		FROM activity_log a
		JOIN users u ON a.user_id = u.id
		WHERE a.project_id = ?
		ORDER BY a.created_at DESC
	`

	if limit != nil && *limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}

	rows, err := r.DB.Query(query, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var activities []*model.Activity
	for rows.Next() {
		var activity model.Activity
		var user model.User
		var oldValue, newValue, metadata sql.NullString

		err := rows.Scan(
			&activity.ID, &activity.TaskID, &activity.ProjectID, &user.ID, &activity.Action,
			&oldValue, &newValue, &metadata, &activity.CreatedAt,
			&user.ID, &user.Email, &user.Name, &user.CreatedAt,
		)
		if err != nil {
			return nil, err
		}

		if oldValue.Valid {
			activity.OldValue = &oldValue.String
		}
		if newValue.Valid {
			activity.NewValue = &newValue.String
		}
		if metadata.Valid {
			activity.Metadata = &metadata.String
		}

		activity.User = &user
		activities = append(activities, &activity)
	}

	return activities, nil
}

// ListShareCodes is the resolver for the listShareCodes field.
func (r *queryResolver) ListShareCodes(ctx context.Context, projectID string) ([]*model.ShareCode, error) {
	panic(fmt.Errorf("not implemented: ListShareCodes - listShareCodes"))
}

// ValidateShareCode is the resolver for the validateShareCode field.
func (r *queryResolver) ValidateShareCode(ctx context.Context, code string) (*model.ShareCode, error) {
	var shareCode model.ShareCode
	err := r.DB.Get(&shareCode, `
		SELECT * FROM share_codes
		WHERE code = ?
	`, code)
	if err != nil {
		return nil, fmt.Errorf("invalid share code")
	}

	// Validate share code
	if shareCode.Revoked {
		return nil, fmt.Errorf("share code has been revoked")
	}
	if shareCode.ExpiresAt != nil && shareCode.ExpiresAt.Before(time.Now()) {
		return nil, fmt.Errorf("share code has expired")
	}
	if shareCode.MaxUses != nil && shareCode.Uses >= *shareCode.MaxUses {
		return nil, fmt.Errorf("share code has reached maximum uses")
	}

	return &shareCode, nil
}

// GetProjectWorkflow is the resolver for the getProjectWorkflow field.
func (r *queryResolver) GetProjectWorkflow(ctx context.Context, projectID string) ([]*model.WorkflowStatus, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Check project access
	var role string
	err := r.DB.Get(&role, `
		SELECT role FROM project_roles 
		WHERE project_id = ? AND user_id = ?
	`, projectID, userID)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}

	var statuses []*model.WorkflowStatus
	err = r.DB.Select(&statuses, `
		SELECT id, project_id, name, color, position, is_terminal
		FROM project_workflow
		WHERE project_id = ?
		ORDER BY position
	`, projectID)
	if err != nil {
		return nil, err
	}

	return statuses, nil
}

// Projects is the resolver for the projects field.
func (r *userResolver) Projects(ctx context.Context, obj *model.User) ([]*model.ProjectRole, error) {
	panic(fmt.Errorf("not implemented: Projects - projects"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
